<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>TiL Microblog</title>
  <subtitle>Today I Learned - Daily discoveries and learnings</subtitle>
  <link href="https://yourdomain.com/feed.xml" rel="self"/>
  <link href="https://yourdomain.com/"/>
  <updated>2025-10-22T00:00:00Z</updated>
  <id>https://yourdomain.com/</id>
  <author>
    <name>Your Name</name>
    <email>you@example.com</email>
  </author>
  <entry>
    <title>HTTP 103 Early Hints Can Speed Up Your Site</title>
    <link href="https://yourdomain.com/posts/2025-10-20-http-103-early-hints/"/>
    <updated>2025-10-20T00:00:00Z</updated>
    <id>https://yourdomain.com/posts/2025-10-20-http-103-early-hints/</id>
    <content type="html"><![CDATA[
      <p>Today I learned about <strong>HTTP 103 Early Hints</strong> - a relatively new status code that can significantly improve page load times!</p>
<h2>What Is It?</h2>
<p>HTTP 103 is an informational status code that allows the server to send headers with hints about resources the page will need, <em>while</em> the server is still preparing the main response.</p>
<h2>How It Works</h2>
<pre><code class="language-http">HTTP/1.1 103 Early Hints
Link: &lt;/style.css&gt;; rel=preload; as=style
Link: &lt;/script.js&gt;; rel=preload; as=script

HTTP/1.1 200 OK
Content-Type: text/html
...
</code></pre>
<p>The browser receives the 103 response first and starts downloading the CSS and JavaScript immediately, even before receiving the HTML!</p>
<h2>Real-World Impact</h2>
<ul>
<li><strong>Cloudflare reported</strong> 30% faster page loads for some sites</li>
<li><strong>Shopify saw</strong> improvements of 20% on time-to-first-byte metrics</li>
<li>Works best when your server has processing time before responding (database queries, API calls, etc.)</li>
</ul>
<h2>Browser Support</h2>
<p>Supported in:</p>
<ul>
<li>Chrome/Edge 103+</li>
<li>Firefox 103+</li>
<li>Safari 16.4+</li>
</ul>
<h2>When To Use</h2>
<p>Best for:</p>
<ul>
<li>Sites with server-side rendering that takes time</li>
<li>When you know what resources will be needed before generating HTML</li>
<li>Dynamic pages where the resource list is predictable</li>
</ul>
<p>This is a simple optimization that can have a big impact on perceived performance!</p>

    ]]></content>
  </entry>
  <entry>
    <title>Git Bisect Makes Bug Hunting Easy</title>
    <link href="https://yourdomain.com/posts/2025-10-21-git-bisect/"/>
    <updated>2025-10-21T00:00:00Z</updated>
    <id>https://yourdomain.com/posts/2025-10-21-git-bisect/</id>
    <content type="html"><![CDATA[
      <p>Today I finally learned how to properly use <code>git bisect</code> and it's an absolute lifesaver for finding bugs!</p>
<h2>The Problem</h2>
<p>You know a bug exists now, and you know it didn't exist 50 commits ago. How do you find which commit introduced it without checking each one manually?</p>
<h2>Enter Git Bisect</h2>
<p>Git bisect uses binary search to find the problematic commit in O(log n) time!</p>
<pre><code class="language-bash"># Start the bisect session
git bisect start

# Mark the current commit as bad
git bisect bad

# Mark a known good commit (e.g., from 2 weeks ago)
git bisect good abc123

# Git checks out a commit in the middle
# Test if the bug exists, then mark it:
git bisect good  # or git bisect bad

# Repeat until git finds the first bad commit
</code></pre>
<h2>Automating It</h2>
<p>You can even automate the testing:</p>
<pre><code class="language-bash">git bisect start HEAD abc123
git bisect run npm test
</code></pre>
<p>Git will automatically test each commit and find the culprit!</p>
<h2>My Experience</h2>
<p>I had a bug that was introduced somewhere in the last 60 commits. Instead of manually checking commits for hours, <code>git bisect</code> found it in about 6 steps (log₂(60) ≈ 6).</p>
<p>This tool is a must-know for any developer working with Git!</p>

    ]]></content>
  </entry>
  <entry>
    <title>CSS Container Queries Are Game Changers</title>
    <link href="https://yourdomain.com/posts/2025-10-22-css-container-queries/"/>
    <updated>2025-10-22T00:00:00Z</updated>
    <id>https://yourdomain.com/posts/2025-10-22-css-container-queries/</id>
    <content type="html"><![CDATA[
      <p>Today I learned about <strong>CSS Container Queries</strong> and they completely change how we think about responsive design!</p>
<h2>What Are Container Queries?</h2>
<p>Unlike media queries that respond to the viewport size, container queries respond to the size of a containing element. This means components can be truly reusable and adaptive.</p>
<h2>Simple Example</h2>
<pre><code class="language-css">.card-container {
  container-type: inline-size;
}

@container (min-width: 400px) {
  .card {
    display: grid;
    grid-template-columns: 1fr 2fr;
  }
}
</code></pre>
<h2>Why This Matters</h2>
<ul>
<li><strong>Component-based responsive design</strong>: Components adapt based on their container, not the viewport</li>
<li><strong>True reusability</strong>: Same component works in sidebar, main content, or anywhere</li>
<li><strong>Better than media queries</strong>: No need to write viewport-specific overrides</li>
</ul>
<p>This is supported in all modern browsers now (2023+). Time to start using it!</p>
<h2>Resources</h2>
<ul>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_container_queries">MDN Container Queries Guide</a></li>
<li>Browser support is excellent across Chrome, Firefox, Safari, and Edge</li>
</ul>

    ]]></content>
  </entry>
</feed>
